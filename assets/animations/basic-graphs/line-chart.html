<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>折れ線グラフアニメーション - 株価変動トレンド</title>
    <link rel="stylesheet" href="../styles/animations.css">
    <link rel="stylesheet" href="../styles/charts.css">
</head>
<body>
    <div class="animation-container">
        <h2 class="chart-title">株価変動トレンド（月次推移）</h2>
        
        <div class="chart-area">
            <div class="line-chart-container">
                <svg class="chart-svg" viewBox="0 0 800 400" id="lineChart">
                    <!-- Grid lines and chart elements will be added by JavaScript -->
                </svg>
                <div class="tooltip" id="tooltip"></div>
            </div>
        </div>
        
        <div class="control-panel">
            <button class="control-btn" id="playBtn" onclick="playAnimation()">再生</button>
            <button class="control-btn pause" id="pauseBtn" onclick="pauseAnimation()">一時停止</button>
            <button class="control-btn reset" id="resetBtn" onclick="resetAnimation()">リセット</button>
            <div class="speed-control">
                <label for="speedSelect">速度:</label>
                <select id="speedSelect" onchange="changeSpeed()">
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2">2x</option>
                </select>
            </div>
        </div>
    </div>

    <script>
        // Sample data for line chart - stock price trend
        const data = [
            { month: '1月', price: 1500, date: '2024-01' },
            { month: '2月', price: 1620, date: '2024-02' },
            { month: '3月', price: 1480, date: '2024-03' },
            { month: '4月', price: 1750, date: '2024-04' },
            { month: '5月', price: 1680, date: '2024-05' },
            { month: '6月', price: 1850, date: '2024-06' },
            { month: '7月', price: 1920, date: '2024-07' },
            { month: '8月', price: 1780, date: '2024-08' },
            { month: '9月', price: 2100, date: '2024-09' },
            { month: '10月', price: 2250, date: '2024-10' }
        ];

        let animationSpeed = 1;
        let isPlaying = false;
        let currentStep = 0;
        let animationTimeout;

        // Chart dimensions
        const margin = { top: 40, right: 60, bottom: 60, left: 80 };
        const width = 800 - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;

        // Scales
        const xScale = (index) => (width / (data.length - 1)) * index;
        const minPrice = Math.min(...data.map(d => d.price));
        const maxPrice = Math.max(...data.map(d => d.price));
        const yScale = (value) => height - ((value - minPrice) / (maxPrice - minPrice)) * height;

        // Path generator
        function generatePath() {
            let path = `M ${margin.left + xScale(0)} ${margin.top + yScale(data[0].price)}`;
            for (let i = 1; i < data.length; i++) {
                path += ` L ${margin.left + xScale(i)} ${margin.top + yScale(data[i].price)}`;
            }
            return path;
        }

        function initChart() {
            const svg = document.getElementById('lineChart');
            
            // Clear existing content
            svg.innerHTML = '';
            
            // Add background grid
            addGrid(svg);
            
            // Add axes
            addAxes(svg);
            
            // Add line path (initially hidden)
            addLinePath(svg);
            
            // Add data points (initially hidden)
            data.forEach((d, i) => {
                addDataPoint(svg, d, i);
            });
        }

        function addGrid(svg) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'grid');
            
            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + (height / 5) * i;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', margin.left + width);
                line.setAttribute('y2', y);
                line.setAttribute('class', 'grid-line');
                g.appendChild(line);
            }
            
            // Vertical grid lines
            for (let i = 0; i < data.length; i++) {
                const x = margin.left + xScale(i);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', margin.top);
                line.setAttribute('x2', x);
                line.setAttribute('y2', margin.top + height);
                line.setAttribute('class', 'grid-line');
                g.appendChild(line);
            }
            
            svg.appendChild(g);
        }

        function addAxes(svg) {
            // X axis
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', margin.left);
            xAxis.setAttribute('y1', margin.top + height);
            xAxis.setAttribute('x2', margin.left + width);
            xAxis.setAttribute('y2', margin.top + height);
            xAxis.setAttribute('class', 'axis');
            svg.appendChild(xAxis);

            // Y axis
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', margin.left);
            yAxis.setAttribute('y1', margin.top);
            yAxis.setAttribute('x2', margin.left);
            yAxis.setAttribute('y2', margin.top + height);
            yAxis.setAttribute('class', 'axis');
            svg.appendChild(yAxis);

            // X axis labels
            data.forEach((d, i) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', margin.left + xScale(i));
                text.setAttribute('y', margin.top + height + 20);
                text.setAttribute('class', 'label-text');
                text.textContent = d.month;
                svg.appendChild(text);
            });

            // Y axis labels
            for (let i = 0; i <= 5; i++) {
                const value = minPrice + ((maxPrice - minPrice) / 5) * (5 - i);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', margin.left - 15);
                text.setAttribute('y', margin.top + (height / 5) * i + 5);
                text.setAttribute('class', 'axis-label');
                text.setAttribute('text-anchor', 'end');
                text.textContent = '¥' + Math.round(value);
                svg.appendChild(text);
            }
        }

        function addLinePath(svg) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', generatePath());
            path.setAttribute('class', 'line-path');
            path.setAttribute('stroke', '#4ECDC4');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            path.setAttribute('opacity', '0');
            
            // Add gradient effect
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'lineGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '0%');
            
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', '#4ECDC4');
            
            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', '#45B7D1');
            
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            svg.appendChild(defs);
            
            path.setAttribute('stroke', 'url(#lineGradient)');
            svg.appendChild(path);
        }

        function addDataPoint(svg, d, index) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', margin.left + xScale(index));
            circle.setAttribute('cy', margin.top + yScale(d.price));
            circle.setAttribute('r', '6');
            circle.setAttribute('fill', 'white');
            circle.setAttribute('stroke', '#4ECDC4');
            circle.setAttribute('stroke-width', '3');
            circle.setAttribute('class', 'data-point');
            circle.setAttribute('opacity', '0');
            
            // Add hover events
            circle.addEventListener('mouseenter', (e) => showTooltip(e, d));
            circle.addEventListener('mouseleave', hideTooltip);
            
            svg.appendChild(circle);

            // Value label
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', margin.left + xScale(index));
            text.setAttribute('y', margin.top + yScale(d.price) - 15);
            text.setAttribute('class', 'value-text');
            text.setAttribute('opacity', '0');
            text.textContent = '¥' + d.price;
            
            svg.appendChild(text);
        }

        function playAnimation() {
            if (isPlaying) return;
            
            isPlaying = true;
            document.getElementById('playBtn').style.opacity = '0.5';
            
            // First animate the line
            animateLine();
        }

        function animateLine() {
            const svg = document.getElementById('lineChart');
            const path = svg.querySelector('.line-path');
            
            // Get path length for animation
            const pathLength = path.getTotalLength();
            
            // Set up the starting positions
            path.style.strokeDasharray = pathLength + ' ' + pathLength;
            path.style.strokeDashoffset = pathLength;
            path.setAttribute('opacity', '1');
            
            // Animate the line drawing
            let startTime = null;
            const duration = 2000 / animationSpeed;
            
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                
                // Ease-out function
                const easeProgress = 1 - Math.pow(1 - progress, 2);
                
                const drawLength = pathLength * easeProgress;
                path.style.strokeDashoffset = pathLength - drawLength;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Start animating points after line is drawn
                    currentStep = 0;
                    animatePoints();
                }
            }
            
            requestAnimationFrame(animate);
        }

        function animatePoints() {
            if (currentStep >= data.length || !isPlaying) {
                isPlaying = false;
                document.getElementById('playBtn').style.opacity = '1';
                return;
            }
            
            const svg = document.getElementById('lineChart');
            const points = svg.querySelectorAll('.data-point');
            const texts = svg.querySelectorAll('.value-text');
            
            const point = points[currentStep];
            const text = texts[currentStep];
            
            // Animate point appearance
            let startTime = null;
            const duration = 300 / animationSpeed;
            
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                
                // Bounce effect
                const easeProgress = progress < 0.5 
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                point.setAttribute('opacity', easeProgress);
                text.setAttribute('opacity', easeProgress);
                
                // Scale effect
                const scale = 0.5 + (0.5 * easeProgress);
                point.setAttribute('r', 6 * scale);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Move to next point
                    currentStep++;
                    animationTimeout = setTimeout(() => {
                        animatePoints();
                    }, 150 / animationSpeed);
                }
            }
            
            requestAnimationFrame(animate);
        }

        function pauseAnimation() {
            isPlaying = false;
            clearTimeout(animationTimeout);
            document.getElementById('playBtn').style.opacity = '1';
        }

        function resetAnimation() {
            pauseAnimation();
            currentStep = 0;
            
            const svg = document.getElementById('lineChart');
            const path = svg.querySelector('.line-path');
            const points = svg.querySelectorAll('.data-point');
            const texts = svg.querySelectorAll('.value-text');
            
            // Reset line
            if (path) {
                path.setAttribute('opacity', '0');
                path.style.strokeDashoffset = path.getTotalLength();
            }
            
            // Reset points
            points.forEach(point => {
                point.setAttribute('opacity', '0');
                point.setAttribute('r', '6');
            });
            
            // Reset labels
            texts.forEach(text => {
                text.setAttribute('opacity', '0');
            });
        }

        function changeSpeed() {
            animationSpeed = parseFloat(document.getElementById('speedSelect').value);
        }

        function showTooltip(event, data) {
            const tooltip = document.getElementById('tooltip');
            const change = data.price - (data.month === '1月' ? data.price : 
                           this.data ? this.data[this.data.findIndex(d => d.month === data.month) - 1]?.price || data.price : data.price);
            const changePercent = change !== 0 ? ((change / (data.price - change)) * 100).toFixed(1) : '0.0';
            
            tooltip.innerHTML = `
                <strong>${data.month}</strong><br>
                株価: ¥${data.price}<br>
                ${change >= 0 ? '↗' : '↘'} ${changePercent}%
            `;
            tooltip.style.left = event.pageX + 'px';
            tooltip.style.top = event.pageY + 'px';
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
        }

        // Initialize chart on load
        window.addEventListener('load', () => {
            initChart();
            // Auto-play after 1 second
            setTimeout(() => {
                playAnimation();
            }, 1000);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            initChart();
        });
    </script>
</body>
</html>